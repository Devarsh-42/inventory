
//Orders table:
create table public.orders (
  id uuid not null default extensions.uuid_generate_v4 (),
  client_name text not null,
  due_date timestamp with time zone not null,
  created_date timestamp with time zone null default now(),
  status text not null default 'queued'::text,
  priority text not null default 'normal'::text,
  special_instructions text null,
  updated_at timestamp with time zone null default now(),
  client_id uuid not null,
  display_id character varying(4) null,
  constraint orders_pkey primary key (id),
  constraint orders_client_id_fkey foreign KEY (client_id) references clients (id) on delete set null,
  constraint check_order_status check (
    (
      status = any (
        array[
          'in_production'::text,
          'completed'::text,
          'ready'::text,
          'shipped'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_orders_client_id on public.orders using btree (client_id) TABLESPACE pg_default;

create unique INDEX IF not exists idx_orders_display_id on public.orders using btree (display_id) TABLESPACE pg_default;

create trigger set_order_display_id BEFORE INSERT on orders for EACH row
execute FUNCTION generate_order_display_id ();

// order_products:
create table public.order_products (
  id uuid not null default extensions.uuid_generate_v4 (),
  order_id uuid null,
  name text not null,
  quantity integer not null,
  completed integer null default 0,
  created_at timestamp with time zone null default now(),
  constraint order_products_pkey primary key (id),
  constraint order_products_order_id_fkey foreign KEY (order_id) references orders (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_order_products_completion on public.order_products using btree (order_id, completed, quantity) TABLESPACE pg_default;

create trigger create_productions_after_order_product_insert
after INSERT on order_products for EACH row
execute FUNCTION update_or_insert_production ();

// productions table:
create table public.productions (
  id uuid not null default extensions.uuid_generate_v4 (),
  target_quantity integer not null,
  completed_quantity integer null default 0,
  status text not null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  order_id uuid null,
  product_name text not null,
  constraint productions_pkey primary key (id),
  constraint unique_order_product unique NULLS not distinct (order_id, product_name),
  constraint productions_order_id_fkey foreign KEY (order_id) references orders (id),
  constraint check_status check (
    (
      status = any (
        array[
          'in_production'::text,
          'completed'::text,
          'ready'::text,
          'shipped'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create trigger delete_null_orders_trigger
after INSERT
or
update on productions for EACH STATEMENT
execute FUNCTION delete_null_order_id_rows ();

create trigger set_productions_updated_at BEFORE
update on productions for EACH row
execute FUNCTION set_updated_at ();

create trigger trg_create_inventory
after INSERT on productions for EACH row
execute FUNCTION create_inventory_after_prod ();

create trigger trg_dispatch_item_after_prod
after INSERT on productions for EACH row
execute FUNCTION create_dispatch_item_after_prod ();

// queue table:
create table public.production_queue (
  id uuid not null default extensions.uuid_generate_v4 (),
  queue_position serial not null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  quantity integer not null,
  completed boolean not null default false,
  inventory_id uuid not null,
  constraint production_queue_pkey primary key (id),
  constraint unique_queue_position unique (queue_position),
  constraint production_queue_inventory_fkey foreign KEY (inventory_id) references inventory (id) on delete CASCADE
) TABLESPACE pg_default;

create trigger set_production_queue_updated_at BEFORE
update on production_queue for EACH row
execute FUNCTION set_updated_at ();

create trigger trg_prod_queue_updated_at BEFORE
update on production_queue for EACH row
execute FUNCTION set_prod_queue_updated_at ();

//completions table:
create table public.production_completions (
  id uuid not null default extensions.uuid_generate_v4 (),
  production_id uuid null,
  product_name text null,
  quantity_completed integer null,
  completed_on timestamp with time zone null default now(),
  shipped boolean null default false,
  shipping_date timestamp with time zone null,
  allocated_quantity integer null default 0,
  constraint production_completions_pkey primary key (id)
) TABLESPACE pg_default;


//dispatch items table:
create table public.dispatch_items (
  id uuid not null default extensions.uuid_generate_v4 (),
  dispatch_id uuid not null,
  production_id uuid not null,
  product_name text not null,
  quantity integer not null,
  is_ready boolean null default false,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  shipped boolean null default false,
  ready_date timestamp with time zone null,
  shipped_date timestamp with time zone null,
  shipping_notes text null,
  ready boolean null default false,
  completed_production_id uuid null,
  batch_number text null,
  batch_quantity integer null,
  batch_notes text null,
  allocated_quantity integer not null default 0,
  constraint dispatch_items_pkey primary key (id),
  constraint dispatch_items_dispatch_id_fkey foreign KEY (dispatch_id) references dispatch (id) on delete CASCADE,
  constraint dispatch_items_production_id_fkey foreign KEY (production_id) references productions (id) on delete CASCADE,
  constraint batch_data_validation check (
    (
      (ready = false)
      or (
        (ready = true)
        and (
          (
            (batch_number is null)
            and (batch_quantity is null)
            and (batch_notes is null)
          )
          or (
            (batch_number is not null)
            and (batch_quantity is not null)
          )
        )
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_dispatch_items_dispatch_id on public.dispatch_items using btree (dispatch_id) TABLESPACE pg_default;

create index IF not exists idx_dispatch_items_batch_number on public.dispatch_items using btree (batch_number) TABLESPACE pg_default;

create trigger allocate_inventory_trigger BEFORE
update OF batch_quantity on dispatch_items for EACH row when (
  new.batch_quantity is not null
  and new.batch_quantity > 0
)
execute FUNCTION allocate_inventory ();

create trigger check_dispatch_items_ready
after
update on dispatch_items for EACH row
execute FUNCTION check_all_items_ready ();

create trigger set_dispatch_items_updated_at BEFORE
update on dispatch_items for EACH row
execute FUNCTION set_updated_at ();

create trigger trg_allocate_inv_on_dispatch_update BEFORE
update OF batch_quantity on dispatch_items for EACH row
execute FUNCTION allocate_inventory_to_dispatch ();

create trigger trg_check_dispatch_ready
after
update OF is_ready on dispatch_items for EACH row
execute FUNCTION check_dispatch_ready ();

create trigger trg_dispatch_alloc BEFORE
update OF allocated_quantity on dispatch_items for EACH row
execute FUNCTION on_dispatch_allocation ();

create trigger update_dispatch_status
after
update OF ready on dispatch_items for EACH row when (new.ready is true)
execute FUNCTION check_dispatch_ready ();

create trigger update_dispatch_status_trigger
after
update OF ready,
shipped on dispatch_items for EACH row
execute FUNCTION update_dispatch_status ();

create trigger update_status_from_dispatch
after
update OF ready,
shipped on dispatch_items for EACH row
execute FUNCTION update_order_status_from_dispatch ();

create trigger validate_batch_quantity_trigger BEFORE INSERT
or
update on dispatch_items for EACH row
execute FUNCTION validate_batch_quantity ();

//dispatch table:
create table public.dispatch (
  id uuid not null default extensions.uuid_generate_v4 (),
  order_id uuid not null,
  client_id uuid not null,
  dispatch_date timestamp with time zone null default now(),
  status text not null default 'pending'::text,
  shipping_notes text null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  tracking_number text null,
  shipped_on timestamp with time zone null,
  constraint dispatch_pkey primary key (id),
  constraint dispatch_order_id_unique unique (order_id),
  constraint dispatch_client_id_fkey foreign KEY (client_id) references clients (id) on delete CASCADE,
  constraint dispatch_order_id_fkey foreign KEY (order_id) references orders (id) on delete CASCADE,
  constraint check_dispatch_status check (
    (
      status = any (
        array[
          'pending'::text,
          'ready'::text,
          'shipped'::text,
          'delivered'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_dispatch_client_id on public.dispatch using btree (client_id) TABLESPACE pg_default;

create index IF not exists idx_dispatch_order_id on public.dispatch using btree (order_id) TABLESPACE pg_default;

create trigger dispatch_delete_cascade BEFORE DELETE on dispatch for EACH row
execute FUNCTION delete_dispatch_cascade ();

create trigger set_dispatch_updated_at BEFORE
update on dispatch for EACH row
execute FUNCTION set_updated_at ();

create trigger trigger_update_order_on_dispatch_status
after
update OF status on dispatch for EACH row
execute FUNCTION update_order_from_dispatch ();

create trigger update_order_status_on_dispatch
after
update OF status on dispatch for EACH row
execute FUNCTION update_order_status_from_dispatch ();

//invnetory table:
create table public.inventory (
  id uuid not null default extensions.uuid_generate_v4 (),
  production_id uuid not null,
  product_name text not null,
  total_quantity integer not null,
  available_qty integer not null default 0,
  allocated_qty integer not null default 0,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint inventory_pkey primary key (id),
  constraint unique_inventory_prod unique (production_id),
  constraint inventory_prod_fkey foreign KEY (production_id) references productions (id) on delete CASCADE,
  constraint check_inventory_quantities check (
    (
      (total_quantity >= 0)
      and (available_qty >= 0)
      and (allocated_qty >= 0)
    )
  )
) TABLESPACE pg_default;

create trigger trg_inventory_updated_at BEFORE
update on inventory for EACH row
execute FUNCTION set_inventory_updated_at ();